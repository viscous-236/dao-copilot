{"version":3,"sources":["../../src/index.ts"],"sourcesContent":["import {\n  ChainIdToNetwork,\n  PaymentRequirementsSchema,\n  Signer,\n  evm,\n  MultiNetworkSigner,\n  isMultiNetworkSigner,\n  isSvmSignerWallet,\n  Network,\n  X402Config,\n} from \"x402/types\";\nimport {\n  createPaymentHeader,\n  PaymentRequirementsSelector,\n  selectPaymentRequirements,\n} from \"x402/client\";\n\n/**\n * Enables the payment of APIs using the x402 payment protocol.\n *\n * This function wraps the native fetch API to automatically handle 402 Payment Required responses\n * by creating and sending a payment header. It will:\n * 1. Make the initial request\n * 2. If a 402 response is received, parse the payment requirements\n * 3. Verify the payment amount is within the allowed maximum\n * 4. Create a payment header using the provided wallet client\n * 5. Retry the request with the payment header\n *\n * @param fetch - The fetch function to wrap (typically globalThis.fetch)\n * @param walletClient - The wallet client used to sign payment messages\n * @param maxValue - The maximum allowed payment amount in base units (defaults to 0.1 USDC)\n * @param paymentRequirementsSelector - A function that selects the payment requirements from the response\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A wrapped fetch function that handles 402 responses automatically\n *\n * @example\n * ```typescript\n * const wallet = new SignerWallet(...);\n * const fetchWithPay = wrapFetchWithPayment(fetch, wallet);\n *\n * // With custom RPC configuration\n * const fetchWithPay = wrapFetchWithPayment(fetch, wallet, undefined, undefined, {\n *   svmConfig: { rpcUrl: \"http://localhost:8899\" }\n * });\n *\n * // Make a request that may require payment\n * const response = await fetchWithPay('https://api.example.com/paid-endpoint');\n * ```\n *\n * @throws {Error} If the payment amount exceeds the maximum allowed value\n * @throws {Error} If the request configuration is missing\n * @throws {Error} If a payment has already been attempted for this request\n * @throws {Error} If there's an error creating the payment header\n */\nexport function wrapFetchWithPayment(\n  fetch: typeof globalThis.fetch,\n  walletClient: Signer | MultiNetworkSigner,\n  maxValue: bigint = BigInt(0.1 * 10 ** 6), // Default to 0.10 USDC\n  paymentRequirementsSelector: PaymentRequirementsSelector = selectPaymentRequirements,\n  config?: X402Config,\n) {\n  return async (input: RequestInfo, init?: RequestInit) => {\n    const response = await fetch(input, init);\n\n    if (response.status !== 402) {\n      return response;\n    }\n\n    const { x402Version, accepts } = (await response.json()) as {\n      x402Version: number;\n      accepts: unknown[];\n    };\n    const parsedPaymentRequirements = accepts.map(x => PaymentRequirementsSchema.parse(x));\n\n    const network = isMultiNetworkSigner(walletClient)\n      ? undefined\n      : evm.isSignerWallet(walletClient as typeof evm.EvmSigner)\n        ? ChainIdToNetwork[(walletClient as typeof evm.EvmSigner).chain?.id]\n        : isSvmSignerWallet(walletClient)\n          ? ([\"solana\", \"solana-devnet\"] as Network[])\n          : undefined;\n\n    const selectedPaymentRequirements = paymentRequirementsSelector(\n      parsedPaymentRequirements,\n      network,\n      \"exact\",\n    );\n\n    if (BigInt(selectedPaymentRequirements.maxAmountRequired) > maxValue) {\n      throw new Error(\"Payment amount exceeds maximum allowed\");\n    }\n\n    const paymentHeader = await createPaymentHeader(\n      walletClient,\n      x402Version,\n      selectedPaymentRequirements,\n      config,\n    );\n\n    if (init && (init as { __is402Retry?: boolean }).__is402Retry) {\n      throw new Error(\"Payment already attempted\");\n    }\n\n    const newInit = {\n      ...init,\n      headers: {\n        ...(init?.headers || {}),\n        \"X-PAYMENT\": paymentHeader,\n        \"Access-Control-Expose-Headers\": \"X-PAYMENT-RESPONSE\",\n      },\n      __is402Retry: true,\n    };\n\n    const secondResponse = await fetch(input, newInit);\n    return secondResponse;\n  };\n}\n\nexport { decodeXPaymentResponse } from \"x402/shared\";\nexport { createSigner, type Signer, type MultiNetworkSigner, type X402Config } from \"x402/types\";\nexport { type PaymentRequirementsSelector } from \"x402/client\";\nexport type { Hex } from \"viem\";\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EAEA;AAAA,EAEA;AAAA,EACA;AAAA,OAGK;AACP;AAAA,EACE;AAAA,EAEA;AAAA,OACK;AAuGP,SAAS,8BAA8B;AACvC,SAAS,oBAA2E;AAjE7E,SAAS,qBACd,OACA,cACA,WAAmB,OAAO,MAAM,MAAM,CAAC,GACvC,8BAA2D,2BAC3D,QACA;AACA,SAAO,OAAO,OAAoB,SAAuB;AA7D3D;AA8DI,UAAM,WAAW,MAAM,MAAM,OAAO,IAAI;AAExC,QAAI,SAAS,WAAW,KAAK;AAC3B,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,aAAa,QAAQ,IAAK,MAAM,SAAS,KAAK;AAItD,UAAM,4BAA4B,QAAQ,IAAI,OAAK,0BAA0B,MAAM,CAAC,CAAC;AAErF,UAAM,UAAU,qBAAqB,YAAY,IAC7C,SACA,IAAI,eAAe,YAAoC,IACrD,kBAAkB,kBAAsC,UAAtC,mBAA6C,EAAE,IACjE,kBAAkB,YAAY,IAC3B,CAAC,UAAU,eAAe,IAC3B;AAER,UAAM,8BAA8B;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,OAAO,4BAA4B,iBAAiB,IAAI,UAAU;AACpE,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAEA,UAAM,gBAAgB,MAAM;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,QAAS,KAAoC,cAAc;AAC7D,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,UAAM,UAAU;AAAA,MACd,GAAG;AAAA,MACH,SAAS;AAAA,QACP,IAAI,6BAAM,YAAW,CAAC;AAAA,QACtB,aAAa;AAAA,QACb,iCAAiC;AAAA,MACnC;AAAA,MACA,cAAc;AAAA,IAChB;AAEA,UAAM,iBAAiB,MAAM,MAAM,OAAO,OAAO;AACjD,WAAO;AAAA,EACT;AACF;","names":[]}