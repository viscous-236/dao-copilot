{"version":3,"sources":["../../../src/shared/index.ts","../../../src/shared/json.ts","../../../src/shared/base64.ts","../../../src/types/shared/money.ts","../../../src/types/shared/network.ts","../../../src/types/shared/evm/wallet.ts","../../../src/shared/svm/wallet.ts","../../../src/shared/svm/rpc.ts","../../../src/types/shared/evm/config.ts","../../../src/types/shared/svm/regex.ts","../../../src/shared/network.ts","../../../src/types/verify/x402Specs.ts","../../../src/types/verify/facilitator.ts","../../../src/shared/evm/usdc.ts","../../../src/shared/middleware.ts","../../../src/shared/svm/index.ts","../../../src/shared/svm/transaction.ts"],"sourcesContent":["export * from \"./json\";\nexport * from \"./base64\";\nexport * from \"./network\";\nexport * from \"./middleware\";\nexport * as svm from \"./svm\";\n","/**\n * Converts an object to a JSON-safe format by converting bigint values to strings\n * and recursively processing nested objects and arrays\n *\n * @param data - The object to convert to JSON-safe format\n * @returns A new object with all bigint values converted to strings\n */\nexport function toJsonSafe<T extends object>(data: T): object {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n\n  /**\n   * Recursively converts values to JSON-safe format\n   *\n   * @param value - The value to convert\n   * @returns The converted value with bigints as strings\n   */\n  function convert(value: unknown): unknown {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n\n  return convert(data) as object;\n}\n","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\n// evm\nexport const SupportedEVMNetworks: Network[] = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"abstract\", 2741],\n  [\"abstract-testnet\", 11124],\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n  [\"polygon\", 137],\n  [\"polygon-amoy\", 80002],\n  [\"peaq\", 3338],\n  [\"story\", 1514],\n  [\"educhain\", 41923],\n  [\"skale-base-sepolia\", 324705682],\n]);\n\n// svm\nexport const SupportedSVMNetworks: Network[] = [\"solana-devnet\", \"solana\"];\nexport const SvmNetworkToChainId = new Map<Network, number>([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101],\n]);\n\nexport const ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map(network => [\n    EvmNetworkToChainId.get(network),\n    network,\n  ]),\n) as Record<number, Network>;\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n  avalanche,\n  iotexTestnet,\n  iotex,\n  abstract,\n  abstractTestnet,\n  story,\n  eduChain,\n} from \"viem/chains\";\nimport { skaleBaseSepolia } from \"../custom-chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\nimport { eip712WalletActions } from \"viem/zksync\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  });\n\n  if (isZkStackChain(chain)) {\n    return walletClient.extend(publicActions).extend(eip712WalletActions());\n  }\n\n  return walletClient.extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nexport function getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"abstract\":\n      return abstract;\n    case \"abstract-testnet\":\n      return abstractTestnet;\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche\":\n      return avalanche;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    case \"story\":\n      return story;\n    case \"educhain\":\n      return eduChain;\n    case \"iotex\":\n      return iotex;\n    case \"iotex-testnet\":\n      return iotexTestnet;\n    case \"skale-base-sepolia\":\n      return skaleBaseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\nconst ZKSTACK_CHAIN_IDS = new Set([\n  2741, // Abstract Mainnet\n  11124, // Abstract Sepolia Testnet\n]);\n\n/**\n * Checks whether the given chain is part of the zkstack stack\n *\n * @param chain - The chain to check\n * @returns True if the chain is a ZK stack chain\n */\nexport function isZkStackChain(chain: Chain): boolean {\n  return ZKSTACK_CHAIN_IDS.has(chain.id);\n}\n","import {\n  createKeyPairSignerFromBytes,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  type TransactionSigner,\n  isTransactionSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = TransactionSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<TransactionSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a Solana transaction signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet satisfies the TransactionSigner interface.\n */\nexport function isSignerWallet(wallet: unknown): wallet is SvmSigner {\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    isTransactionSigner(wallet as TransactionSigner)\n  );\n}\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Default public RPC endpoint for Solana devnet\n */\nconst DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\n\n/**\n * Default public RPC endpoint for Solana mainnet\n */\nconst MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana devnet\n */\nconst DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana mainnet\n */\nconst MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n *\n * Converts an HTTP URL to a WebSocket URL\n *\n * @param url - The URL to convert to a WebSocket URL\n * @returns The WebSocket URL\n */\nfunction httpToWs(url: string): string {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n","import { Address } from \"viem\";\nimport { Address as SolanaAddress } from \"@solana/kit\";\n\nexport const config: Record<string, ChainConfig> = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\",\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USD Coin\",\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\",\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USD Coin\",\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\",\n  },\n  // solana devnet\n  \"103\": {\n    usdcAddress: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  // solana mainnet\n  \"101\": {\n    usdcAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  \"1328\": {\n    usdcAddress: \"0x4fcf1784b31630811181f670aea7a7bef803eaed\",\n    usdcName: \"USDC\",\n  },\n  \"1329\": {\n    usdcAddress: \"0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392\",\n    usdcName: \"USDC\",\n  },\n  \"137\": {\n    usdcAddress: \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\",\n    usdcName: \"USD Coin\",\n  },\n  \"80002\": {\n    usdcAddress: \"0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582\",\n    usdcName: \"USDC\",\n  },\n  \"3338\": {\n    usdcAddress: \"0xbbA60da06c2c5424f03f7434542280FCAd453d10\",\n    usdcName: \"USDC\",\n  },\n  \"2741\": {\n    usdcAddress: \"0x84a71ccd554cc1b02749b35d22f684cc8ec987e1\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"11124\": {\n    usdcAddress: \"0xe4C7fBB0a626ed208021ccabA6Be1566905E2dFc\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"1514\": {\n    usdcAddress: \"0xF1815bd50389c46847f0Bda824eC8da914045D14\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"41923\": {\n    usdcAddress: \"0x12a272A581feE5577A5dFa371afEB4b2F3a8C2F8\",\n    usdcName: \"Bridged USDC (Stargate)\",\n  },\n  \"324705682\": {\n    usdcAddress: \"0x2e08028E3C4c2356572E096d8EF835cD5C6030bD\",\n    usdcName: \"Bridged USDC (SKALE Bridge)\",\n  },\n};\n\nexport type ChainConfig = {\n  usdcAddress: Address | SolanaAddress;\n  usdcName: string;\n};\n","export const SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n","import { EvmNetworkToChainId, Network, SvmNetworkToChainId } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network)!;\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","import { Account, Address, Chain, Client, Transport } from \"viem\";\nimport { ChainConfig, config } from \"../../types/shared/evm/config\";\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC contract address for the current chain from the client\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns The USDC contract address for the current chain\n */\nexport function getUsdcAddress<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<transport, chain, account>): Address {\n  return config[client.chain!.id.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC contract address for a specific chain ID\n *\n * @deprecated Use `getUsdcChainConfigForChain` instead\n * @param chainId - The chain ID to get the USDC contract address for\n * @returns The USDC contract address for the specified chain\n */\nexport function getUsdcAddressForChain(chainId: number): Address {\n  return config[chainId.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC address and eip712 domain name for a specific chain ID\n *\n * @param chainId - The chain ID\n * @returns The USDC contract address and eip712 domain name  for the specified chain\n */\nexport function getUsdcChainConfigForChain(chainId: number): ChainConfig | undefined {\n  return config[chainId.toString()];\n}\n\n// Cache for storing the version value\nlet versionCache: string | null = null;\n\n/**\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns A promise that resolves to the USDC contract version string\n */\nexport async function getVersion<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\n  // Return cached version if available\n  if (versionCache !== null) {\n    return versionCache;\n  }\n\n  // Fetch and cache version if not available\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi,\n    functionName: \"version\",\n  });\n  versionCache = version as string;\n  return versionCache;\n}\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getUSDCBalance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\n  const chainId = client.chain!.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress as `0x${string}`,\n    abi,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","import { Address, Hex } from \"viem\";\nimport {\n  moneySchema,\n  Network,\n  Price,\n  RouteConfig,\n  RoutePattern,\n  ERC20TokenAmount,\n  PaymentRequirements,\n  PaymentPayload,\n  SPLTokenAmount,\n} from \"../types\";\nimport { RoutesConfig } from \"../types\";\nimport { safeBase64Decode } from \"./base64\";\nimport { getUsdcChainConfigForChain } from \"./evm\";\nimport { getNetworkId } from \"./network\";\n\n/**\n * Computes the route patterns for the given routes config\n *\n * @param routes - The routes config to compute the patterns for\n * @returns The route patterns\n */\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\"\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\n        : (value as RouteConfig),\n    ]),\n  );\n\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${\n          path\n            // First escape all special regex characters except * and []\n            .replace(/[$()+.?^{|}]/g, \"\\\\$&\")\n            // Then handle our special pattern characters\n            .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\n            .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Convert [param] to regex capture\n            .replace(/\\//g, \"\\\\/\") // Escape slashes\n        }$`,\n        \"i\",\n      ),\n      config: routeConfig,\n    };\n  });\n}\n\n/**\n * Finds the matching route pattern for the given path and method\n *\n * @param routePatterns - The route patterns to search through\n * @param path - The path to match against\n * @param method - The HTTP method to match against\n * @returns The matching route pattern or undefined if no match is found\n */\nexport function findMatchingRoute(\n  routePatterns: RoutePattern[],\n  path: string,\n  method: string,\n): RoutePattern | undefined {\n  // Normalize the path:\n  // 1. Remove query parameters and hash fragments\n  // 2. Replace backslashes with forward slashes\n  // 3. Replace multiple consecutive slashes with a single slash\n  // 4. Keep trailing slash if path is not root\n  let normalizedPath: string;\n  try {\n    // First split off query parameters and hash fragments\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    // Then decode the path - this needs to happen before any normalization\n    // so encoded characters are properly handled\n    const decodedPath = decodeURIComponent(pathWithoutQuery);\n\n    // Normalize the path (just clean up slashes)\n    normalizedPath = decodedPath\n      .replace(/\\\\/g, \"/\") // replace backslashes\n      .replace(/\\/+/g, \"/\") // collapse slashes\n      .replace(/(.+?)\\/+$/, \"$1\"); // trim trailing slashes\n  } catch {\n    // If decoding fails (e.g., invalid % encoding), return undefined\n    return undefined;\n  }\n\n  // Find matching route pattern\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(normalizedPath);\n    const upperMethod = method.toUpperCase();\n    const matchesVerb = verb === \"*\" || upperMethod === verb;\n\n    const result = matchesPath && matchesVerb;\n    return result;\n  });\n\n  if (matchingRoutes.length === 0) {\n    return undefined;\n  }\n\n  // Use the most specific route (longest path pattern)\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\n    b.pattern.source.length > a.pattern.source.length ? b : a,\n  );\n\n  return matchingRoute;\n}\n\n/**\n * Gets the default asset (USDC) for the given network\n *\n * @param network - The network to get the default asset for\n * @returns The default asset\n */\nexport function getDefaultAsset(network: Network) {\n  const chainId = getNetworkId(network);\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    throw new Error(`Unable to get default asset on ${network}`);\n  }\n  return {\n    address: usdc.usdcAddress,\n    decimals: 6,\n    eip712: {\n      name: usdc.usdcName,\n      version: \"2\",\n    },\n  };\n}\n\n/**\n * Parses the amount from the given price\n *\n * @param price - The price to parse\n * @param network - The network to get the default asset for\n * @returns The parsed amount or an error message\n */\nexport function processPriceToAtomicAmount(\n  price: Price,\n  network: Network,\n):\n  | { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"] }\n  | { error: string } {\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\n  let maxAmountRequired: string;\n  let asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"];\n\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    // USDC amount in dollars\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    // Token amount in atomic units\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n\n  return {\n    maxAmountRequired,\n    asset,\n  };\n}\n\n/**\n * Finds the matching payment requirements for the given payment\n *\n * @param paymentRequirements - The payment requirements to search through\n * @param payment - The payment to match against\n * @returns The matching payment requirements or undefined if no match is found\n */\nexport function findMatchingPaymentRequirements(\n  paymentRequirements: PaymentRequirements[],\n  payment: PaymentPayload,\n) {\n  return paymentRequirements.find(\n    value => value.scheme === payment.scheme && value.network === payment.network,\n  );\n}\n\n/**\n * Decodes the X-PAYMENT-RESPONSE header\n *\n * @param header - The X-PAYMENT-RESPONSE header to decode\n * @returns The decoded payment response\n */\nexport function decodeXPaymentResponse(header: string) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as {\n    success: boolean;\n    transaction: Hex;\n    network: Network;\n    payer: Address;\n  };\n}\n","export * from \"./rpc\";\nexport * from \"./wallet\";\nexport * from \"./transaction\";\n","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type TransactionSigner,\n  isTransactionModifyingSigner,\n  isTransactionPartialSigner,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n  CompiledTransactionMessage,\n  TransactionWithLifetime,\n  TransactionWithinSizeLimit,\n  type SignatureDictionary,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account)\n * from the TransferChecked instruction.\n *\n * @param transaction - The transaction to extract the token payer from\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      if (accountIndices.length >= 4) {\n        // TransferChecked account order: [source, mint, destination, owner, ...]\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: TransactionSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  const signedTransaction = await signTransactionWithSigner(signer, transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: true,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n\n/**\n * Signs a transaction using the provided {@link TransactionSigner}.\n *\n * Prefers modifying signers (wallets that can rewrite the transaction) and falls\n * back to partial signers that only append signatures.\n *\n * @param signer - Wallet or signer capable of producing transaction signatures\n * @param transaction - Compiled transaction to sign\n * @returns The transaction including any signatures added by the signer\n */\nexport async function signTransactionWithSigner<TTransaction extends Transaction>(\n  signer: TransactionSigner,\n  transaction: TTransaction,\n): Promise<TTransaction> {\n  if (isTransactionModifyingSigner(signer)) {\n    const [modifiedTransaction] = await signer.modifyAndSignTransactions([transaction]);\n    if (!modifiedTransaction) {\n      throw new Error(\"transaction_signer_failed_to_return_transaction\");\n    }\n    return modifiedTransaction as TTransaction;\n  }\n\n  if (isTransactionPartialSigner(signer)) {\n    const [signatures] = await signer.signTransactions([\n      transaction as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime,\n    ]);\n    if (!signatures) {\n      throw new Error(\"transaction_signer_failed_to_return_signatures\");\n    }\n    return mergeTransactionSignatures(transaction, signatures);\n  }\n\n  throw new Error(\"transaction_signer_must_support_offline_signing\");\n}\n\n/**\n * Returns a copy of `transaction` with additional signatures merged in.\n *\n * @param transaction - Transaction whose signature map should be augmented\n * @param signatures - Map of addresses to new signature bytes\n * @returns A frozen transaction containing the merged signature map\n */\nfunction mergeTransactionSignatures<TTransaction extends Transaction>(\n  transaction: TTransaction,\n  signatures: SignatureDictionary,\n): TTransaction {\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...signatures,\n    }),\n  }) as TTransaction;\n}\n"],"mappings":"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","names":["svm_exports","import_zod","import_kit","import_zod","import_zod","svm_exports","import_kit"]}