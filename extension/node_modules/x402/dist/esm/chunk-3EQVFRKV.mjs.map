{"version":3,"sources":["../../src/types/shared/money.ts","../../src/types/shared/network.ts","../../src/types/shared/evm/wallet.ts","../../src/types/shared/custom-chains/eip155-324705682.ts","../../src/shared/svm/wallet.ts","../../src/shared/svm/rpc.ts","../../src/types/shared/wallet.ts","../../src/types/shared/evm/index.ts","../../src/types/shared/evm/eip3009.ts","../../src/types/shared/svm/index.ts","../../src/types/shared/svm/regex.ts","../../src/types/verify/x402Specs.ts","../../src/shared/base64.ts","../../src/types/verify/facilitator.ts","../../src/shared/json.ts","../../src/shared/network.ts","../../src/shared/middleware.ts","../../src/shared/svm/index.ts","../../src/shared/svm/transaction.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\n// evm\nexport const SupportedEVMNetworks: Network[] = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"abstract\", 2741],\n  [\"abstract-testnet\", 11124],\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n  [\"polygon\", 137],\n  [\"polygon-amoy\", 80002],\n  [\"peaq\", 3338],\n  [\"story\", 1514],\n  [\"educhain\", 41923],\n  [\"skale-base-sepolia\", 324705682],\n]);\n\n// svm\nexport const SupportedSVMNetworks: Network[] = [\"solana-devnet\", \"solana\"];\nexport const SvmNetworkToChainId = new Map<Network, number>([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101],\n]);\n\nexport const ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map(network => [\n    EvmNetworkToChainId.get(network),\n    network,\n  ]),\n) as Record<number, Network>;\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n  avalanche,\n  iotexTestnet,\n  iotex,\n  abstract,\n  abstractTestnet,\n  story,\n  eduChain,\n} from \"viem/chains\";\nimport { skaleBaseSepolia } from \"../custom-chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\nimport { eip712WalletActions } from \"viem/zksync\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  });\n\n  if (isZkStackChain(chain)) {\n    return walletClient.extend(publicActions).extend(eip712WalletActions());\n  }\n\n  return walletClient.extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nexport function getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"abstract\":\n      return abstract;\n    case \"abstract-testnet\":\n      return abstractTestnet;\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche\":\n      return avalanche;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    case \"story\":\n      return story;\n    case \"educhain\":\n      return eduChain;\n    case \"iotex\":\n      return iotex;\n    case \"iotex-testnet\":\n      return iotexTestnet;\n    case \"skale-base-sepolia\":\n      return skaleBaseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\nconst ZKSTACK_CHAIN_IDS = new Set([\n  2741, // Abstract Mainnet\n  11124, // Abstract Sepolia Testnet\n]);\n\n/**\n * Checks whether the given chain is part of the zkstack stack\n *\n * @param chain - The chain to check\n * @returns True if the chain is a ZK stack chain\n */\nexport function isZkStackChain(chain: Chain): boolean {\n  return ZKSTACK_CHAIN_IDS.has(chain.id);\n}\n","import { type Chain } from \"viem\";\n\n// This chain isactive and is waiting for addition to https://github.com/ethereum-lists/chains\n// before it can be added to wevm/viem/chains.\nexport const skaleBaseSepolia = {\n  id: 324705682,\n  name: \"SKALE Base Sepolia\",\n  nativeCurrency: {\n    name: \"Credits\",\n    symbol: \"CREDITS\",\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: [\"https://base-sepolia-testnet.skalenodes.com/v1/jubilant-horrible-ancha\"],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: \"Blockscout\",\n      url: \"https://base-sepolia-testnet-explorer.skalenodes.com\",\n      apiUrl: \"https://base-sepolia-testnet-explorer.skalenodes.com/api\",\n    },\n  },\n} satisfies Chain;\n","import {\n  createKeyPairSignerFromBytes,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  type TransactionSigner,\n  isTransactionSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = TransactionSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<TransactionSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a Solana transaction signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet satisfies the TransactionSigner interface.\n */\nexport function isSignerWallet(wallet: unknown): wallet is SvmSigner {\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    isTransactionSigner(wallet as TransactionSigner)\n  );\n}\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Default public RPC endpoint for Solana devnet\n */\nconst DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\n\n/**\n * Default public RPC endpoint for Solana mainnet\n */\nconst MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana devnet\n */\nconst DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana mainnet\n */\nconst MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n *\n * Converts an HTTP URL to a WebSocket URL\n *\n * @param url - The URL to convert to a WebSocket URL\n * @returns The WebSocket URL\n */\nfunction httpToWs(url: string): string {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n","import * as evm from \"./evm/wallet\";\nimport * as svm from \"../../shared/svm/wallet\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"./network\";\nimport { Hex } from \"viem\";\n\nexport type ConnectedClient = evm.ConnectedClient | svm.SvmConnectedClient;\nexport type Signer = evm.EvmSigner | svm.SvmSigner;\nexport type MultiNetworkSigner = { evm: evm.EvmSigner; svm: svm.SvmSigner };\n\n/**\n * Creates a public client configured for the specified network.\n *\n * @param network - The network to connect to.\n * @returns A public client instance connected to the specified chain.\n */\nexport function createConnectedClient(network: string): ConnectedClient {\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return evm.createConnectedClient(network);\n  }\n\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSvmConnectedClient(network);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key.\n *\n * @param network - The network to connect to.\n * @param privateKey - The private key to use for signing transactions. This should be a hex string for EVM or a base58 encoded string for SVM.\n * @returns A wallet client instance connected to the specified chain with the provided private key.\n */\nexport function createSigner(network: string, privateKey: Hex | string): Promise<Signer> {\n  // evm\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return Promise.resolve(evm.createSigner(network, privateKey as Hex));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSignerFromBase58(privateKey as string);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Checks if the given wallet is an EVM signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is an EVM signer wallet, false otherwise.\n */\nexport function isEvmSignerWallet(wallet: Signer): wallet is evm.EvmSigner {\n  return evm.isSignerWallet(wallet as evm.EvmSigner) || evm.isAccount(wallet as evm.EvmSigner);\n}\n\n/**\n * Checks if the given wallet is an SVM signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is an SVM signer wallet, false otherwise\n */\nexport function isSvmSignerWallet(wallet: Signer): wallet is svm.SvmSigner {\n  return svm.isSignerWallet(wallet);\n}\n\n/**\n * Checks if the given wallet is a multi network signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is a multi network signer wallet, false otherwise\n */\nexport function isMultiNetworkSigner(wallet: object): wallet is MultiNetworkSigner {\n  return \"evm\" in wallet && \"svm\" in wallet;\n}\n","export * from \"./config\";\nexport * from \"./eip3009\";\nexport * from \"./erc20PermitABI\";\nexport * from \"./wallet\";\n","export const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n};\n\nexport const authorizationPrimaryType = \"TransferWithAuthorization\";\n","export * from \"./regex\";\n","export const SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","/**\n * Converts an object to a JSON-safe format by converting bigint values to strings\n * and recursively processing nested objects and arrays\n *\n * @param data - The object to convert to JSON-safe format\n * @returns A new object with all bigint values converted to strings\n */\nexport function toJsonSafe<T extends object>(data: T): object {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n\n  /**\n   * Recursively converts values to JSON-safe format\n   *\n   * @param value - The value to convert\n   * @returns The converted value with bigints as strings\n   */\n  function convert(value: unknown): unknown {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n\n  return convert(data) as object;\n}\n","import { EvmNetworkToChainId, Network, SvmNetworkToChainId } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network)!;\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { Address, Hex } from \"viem\";\nimport {\n  moneySchema,\n  Network,\n  Price,\n  RouteConfig,\n  RoutePattern,\n  ERC20TokenAmount,\n  PaymentRequirements,\n  PaymentPayload,\n  SPLTokenAmount,\n} from \"../types\";\nimport { RoutesConfig } from \"../types\";\nimport { safeBase64Decode } from \"./base64\";\nimport { getUsdcChainConfigForChain } from \"./evm\";\nimport { getNetworkId } from \"./network\";\n\n/**\n * Computes the route patterns for the given routes config\n *\n * @param routes - The routes config to compute the patterns for\n * @returns The route patterns\n */\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\"\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\n        : (value as RouteConfig),\n    ]),\n  );\n\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${\n          path\n            // First escape all special regex characters except * and []\n            .replace(/[$()+.?^{|}]/g, \"\\\\$&\")\n            // Then handle our special pattern characters\n            .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\n            .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Convert [param] to regex capture\n            .replace(/\\//g, \"\\\\/\") // Escape slashes\n        }$`,\n        \"i\",\n      ),\n      config: routeConfig,\n    };\n  });\n}\n\n/**\n * Finds the matching route pattern for the given path and method\n *\n * @param routePatterns - The route patterns to search through\n * @param path - The path to match against\n * @param method - The HTTP method to match against\n * @returns The matching route pattern or undefined if no match is found\n */\nexport function findMatchingRoute(\n  routePatterns: RoutePattern[],\n  path: string,\n  method: string,\n): RoutePattern | undefined {\n  // Normalize the path:\n  // 1. Remove query parameters and hash fragments\n  // 2. Replace backslashes with forward slashes\n  // 3. Replace multiple consecutive slashes with a single slash\n  // 4. Keep trailing slash if path is not root\n  let normalizedPath: string;\n  try {\n    // First split off query parameters and hash fragments\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    // Then decode the path - this needs to happen before any normalization\n    // so encoded characters are properly handled\n    const decodedPath = decodeURIComponent(pathWithoutQuery);\n\n    // Normalize the path (just clean up slashes)\n    normalizedPath = decodedPath\n      .replace(/\\\\/g, \"/\") // replace backslashes\n      .replace(/\\/+/g, \"/\") // collapse slashes\n      .replace(/(.+?)\\/+$/, \"$1\"); // trim trailing slashes\n  } catch {\n    // If decoding fails (e.g., invalid % encoding), return undefined\n    return undefined;\n  }\n\n  // Find matching route pattern\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(normalizedPath);\n    const upperMethod = method.toUpperCase();\n    const matchesVerb = verb === \"*\" || upperMethod === verb;\n\n    const result = matchesPath && matchesVerb;\n    return result;\n  });\n\n  if (matchingRoutes.length === 0) {\n    return undefined;\n  }\n\n  // Use the most specific route (longest path pattern)\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\n    b.pattern.source.length > a.pattern.source.length ? b : a,\n  );\n\n  return matchingRoute;\n}\n\n/**\n * Gets the default asset (USDC) for the given network\n *\n * @param network - The network to get the default asset for\n * @returns The default asset\n */\nexport function getDefaultAsset(network: Network) {\n  const chainId = getNetworkId(network);\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    throw new Error(`Unable to get default asset on ${network}`);\n  }\n  return {\n    address: usdc.usdcAddress,\n    decimals: 6,\n    eip712: {\n      name: usdc.usdcName,\n      version: \"2\",\n    },\n  };\n}\n\n/**\n * Parses the amount from the given price\n *\n * @param price - The price to parse\n * @param network - The network to get the default asset for\n * @returns The parsed amount or an error message\n */\nexport function processPriceToAtomicAmount(\n  price: Price,\n  network: Network,\n):\n  | { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"] }\n  | { error: string } {\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\n  let maxAmountRequired: string;\n  let asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"];\n\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    // USDC amount in dollars\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    // Token amount in atomic units\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n\n  return {\n    maxAmountRequired,\n    asset,\n  };\n}\n\n/**\n * Finds the matching payment requirements for the given payment\n *\n * @param paymentRequirements - The payment requirements to search through\n * @param payment - The payment to match against\n * @returns The matching payment requirements or undefined if no match is found\n */\nexport function findMatchingPaymentRequirements(\n  paymentRequirements: PaymentRequirements[],\n  payment: PaymentPayload,\n) {\n  return paymentRequirements.find(\n    value => value.scheme === payment.scheme && value.network === payment.network,\n  );\n}\n\n/**\n * Decodes the X-PAYMENT-RESPONSE header\n *\n * @param header - The X-PAYMENT-RESPONSE header to decode\n * @returns The decoded payment response\n */\nexport function decodeXPaymentResponse(header: string) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as {\n    success: boolean;\n    transaction: Hex;\n    network: Network;\n    payer: Address;\n  };\n}\n","export * from \"./rpc\";\nexport * from \"./wallet\";\nexport * from \"./transaction\";\n","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type TransactionSigner,\n  isTransactionModifyingSigner,\n  isTransactionPartialSigner,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n  CompiledTransactionMessage,\n  TransactionWithLifetime,\n  TransactionWithinSizeLimit,\n  type SignatureDictionary,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account)\n * from the TransferChecked instruction.\n *\n * @param transaction - The transaction to extract the token payer from\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      if (accountIndices.length >= 4) {\n        // TransferChecked account order: [source, mint, destination, owner, ...]\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: TransactionSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  const signedTransaction = await signTransactionWithSigner(signer, transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: true,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n\n/**\n * Signs a transaction using the provided {@link TransactionSigner}.\n *\n * Prefers modifying signers (wallets that can rewrite the transaction) and falls\n * back to partial signers that only append signatures.\n *\n * @param signer - Wallet or signer capable of producing transaction signatures\n * @param transaction - Compiled transaction to sign\n * @returns The transaction including any signatures added by the signer\n */\nexport async function signTransactionWithSigner<TTransaction extends Transaction>(\n  signer: TransactionSigner,\n  transaction: TTransaction,\n): Promise<TTransaction> {\n  if (isTransactionModifyingSigner(signer)) {\n    const [modifiedTransaction] = await signer.modifyAndSignTransactions([transaction]);\n    if (!modifiedTransaction) {\n      throw new Error(\"transaction_signer_failed_to_return_transaction\");\n    }\n    return modifiedTransaction as TTransaction;\n  }\n\n  if (isTransactionPartialSigner(signer)) {\n    const [signatures] = await signer.signTransactions([\n      transaction as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime,\n    ]);\n    if (!signatures) {\n      throw new Error(\"transaction_signer_failed_to_return_signatures\");\n    }\n    return mergeTransactionSignatures(transaction, signatures);\n  }\n\n  throw new Error(\"transaction_signer_must_support_offline_signing\");\n}\n\n/**\n * Returns a copy of `transaction` with additional signatures merged in.\n *\n * @param transaction - Transaction whose signature map should be augmented\n * @param signatures - Map of addresses to new signature bytes\n * @returns A frozen transaction containing the merged signature map\n */\nfunction mergeTransactionSignatures<TTransaction extends Transaction>(\n  transaction: TTransaction,\n  signatures: SignatureDictionary,\n): TTransaction {\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...signatures,\n    }),\n  }) as TTransaction;\n}\n"],"mappings":"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","names":["z","isSignerWallet","createConnectedClient","createSigner","isSignerWallet","z","z","z","svm_exports","isSignerWallet","z"]}