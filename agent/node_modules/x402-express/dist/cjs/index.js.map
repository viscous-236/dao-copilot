{"version":3,"sources":["../../src/index.ts"],"sourcesContent":["import { NextFunction, Request, Response } from \"express\";\nimport { Address, getAddress } from \"viem\";\nimport { Address as SolanaAddress } from \"@solana/kit\";\nimport { exact } from \"x402/schemes\";\nimport {\n  computeRoutePatterns,\n  findMatchingPaymentRequirements,\n  findMatchingRoute,\n  processPriceToAtomicAmount,\n  toJsonSafe,\n} from \"x402/shared\";\nimport { getPaywallHtml } from \"x402/paywall\";\nimport {\n  FacilitatorConfig,\n  ERC20TokenAmount,\n  moneySchema,\n  PaymentPayload,\n  PaymentRequirements,\n  PaywallConfig,\n  Resource,\n  RoutesConfig,\n  settleResponseHeader,\n  SupportedEVMNetworks,\n  SupportedSVMNetworks,\n} from \"x402/types\";\nimport { useFacilitator } from \"x402/verify\";\n\n/**\n * Creates a payment middleware factory for Express\n *\n * @param payTo - The address to receive payments\n * @param routes - Configuration for protected routes and their payment requirements\n * @param facilitator - Optional configuration for the payment facilitator service\n * @param paywall - Optional configuration for the default paywall\n * @returns An Express middleware handler\n *\n * @example\n * ```typescript\n * // Simple configuration - All endpoints are protected by $0.01 of USDC on base-sepolia\n * app.use(paymentMiddleware(\n *   '0x123...', // payTo address\n *   {\n *     price: '$0.01', // USDC amount in dollars\n *     network: 'base-sepolia'\n *   },\n *   // Optional facilitator configuration. Defaults to x402.org/facilitator for testnet usage\n * ));\n *\n * // Advanced configuration - Endpoint-specific payment requirements & custom facilitator\n * app.use(paymentMiddleware('0x123...', // payTo: The address to receive payments*    {\n *   {\n *     '/weather/*': {\n *       price: '$0.001', // USDC amount in dollars\n *       network: 'base',\n *       config: {\n *         description: 'Access to weather data'\n *       }\n *     }\n *   },\n *   {\n *     url: 'https://facilitator.example.com',\n *     createAuthHeaders: async () => ({\n *       verify: { \"Authorization\": \"Bearer token\" },\n *       settle: { \"Authorization\": \"Bearer token\" }\n *     })\n *   },\n *   {\n *     cdpClientKey: 'your-cdp-client-key',\n *     appLogo: '/images/logo.svg',\n *     appName: 'My App',\n *   }\n * ));\n * ```\n */\nexport function paymentMiddleware(\n  payTo: Address | SolanaAddress,\n  routes: RoutesConfig,\n  facilitator?: FacilitatorConfig,\n  paywall?: PaywallConfig,\n) {\n  const { verify, settle, supported } = useFacilitator(facilitator);\n  const x402Version = 1;\n\n  // Pre-compile route patterns to regex and extract verbs\n  const routePatterns = computeRoutePatterns(routes);\n\n  return async function paymentMiddleware(\n    req: Request,\n    res: Response,\n    next: NextFunction,\n  ): Promise<void> {\n    const matchingRoute = findMatchingRoute(routePatterns, req.path, req.method.toUpperCase());\n\n    if (!matchingRoute) {\n      return next();\n    }\n\n    const { price, network, config = {} } = matchingRoute.config;\n    const {\n      description,\n      mimeType,\n      maxTimeoutSeconds,\n      inputSchema,\n      outputSchema,\n      customPaywallHtml,\n      resource,\n      discoverable,\n    } = config;\n\n    const atomicAmountForAsset = processPriceToAtomicAmount(price, network);\n    if (\"error\" in atomicAmountForAsset) {\n      throw new Error(atomicAmountForAsset.error);\n    }\n    const { maxAmountRequired, asset } = atomicAmountForAsset;\n\n    const resourceUrl: Resource =\n      resource || (`${req.protocol}://${req.headers.host}${req.path}` as Resource);\n\n    let paymentRequirements: PaymentRequirements[] = [];\n\n    // TODO: create a shared middleware function to build payment requirements\n    // evm networks\n    if (SupportedEVMNetworks.includes(network)) {\n      paymentRequirements.push({\n        scheme: \"exact\",\n        network,\n        maxAmountRequired,\n        resource: resourceUrl,\n        description: description ?? \"\",\n        mimeType: mimeType ?? \"\",\n        payTo: getAddress(payTo),\n        maxTimeoutSeconds: maxTimeoutSeconds ?? 60,\n        asset: getAddress(asset.address),\n        // TODO: Rename outputSchema to requestStructure\n        outputSchema: {\n          input: {\n            type: \"http\",\n            method: req.method.toUpperCase(),\n            discoverable: discoverable ?? true,\n            ...inputSchema,\n          },\n          output: outputSchema,\n        },\n        extra: (asset as ERC20TokenAmount[\"asset\"]).eip712,\n      });\n    }\n\n    // svm networks\n    else if (SupportedSVMNetworks.includes(network)) {\n      // get the supported payments from the facilitator\n      const paymentKinds = await supported();\n\n      // find the payment kind that matches the network and scheme\n      let feePayer: string | undefined;\n      for (const kind of paymentKinds.kinds) {\n        if (kind.network === network && kind.scheme === \"exact\") {\n          feePayer = kind?.extra?.feePayer;\n          break;\n        }\n      }\n\n      // if no fee payer is found, throw an error\n      if (!feePayer) {\n        throw new Error(`The facilitator did not provide a fee payer for network: ${network}.`);\n      }\n\n      paymentRequirements.push({\n        scheme: \"exact\",\n        network,\n        maxAmountRequired,\n        resource: resourceUrl,\n        description: description ?? \"\",\n        mimeType: mimeType ?? \"\",\n        payTo: payTo,\n        maxTimeoutSeconds: maxTimeoutSeconds ?? 60,\n        asset: asset.address,\n        // TODO: Rename outputSchema to requestStructure\n        outputSchema: {\n          input: {\n            type: \"http\",\n            method: req.method.toUpperCase(),\n            discoverable: discoverable ?? true,\n            ...inputSchema,\n          },\n          output: outputSchema,\n        },\n        extra: {\n          feePayer,\n        },\n      });\n    } else {\n      throw new Error(`Unsupported network: ${network}`);\n    }\n\n    const payment = req.header(\"X-PAYMENT\");\n    const userAgent = req.header(\"User-Agent\") || \"\";\n    const acceptHeader = req.header(\"Accept\") || \"\";\n    const isWebBrowser = acceptHeader.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n\n    if (!payment) {\n      // TODO handle paywall html for solana\n      if (isWebBrowser) {\n        let displayAmount: number;\n        if (typeof price === \"string\" || typeof price === \"number\") {\n          const parsed = moneySchema.safeParse(price);\n          if (parsed.success) {\n            displayAmount = parsed.data;\n          } else {\n            displayAmount = Number.NaN;\n          }\n        } else {\n          displayAmount = Number(price.amount) / 10 ** price.asset.decimals;\n        }\n\n        const html =\n          customPaywallHtml ||\n          getPaywallHtml({\n            amount: displayAmount,\n            paymentRequirements: toJsonSafe(paymentRequirements) as Parameters<\n              typeof getPaywallHtml\n            >[0][\"paymentRequirements\"],\n            currentUrl: req.originalUrl,\n            testnet: network === \"base-sepolia\",\n            cdpClientKey: paywall?.cdpClientKey,\n            appName: paywall?.appName,\n            appLogo: paywall?.appLogo,\n            sessionTokenEndpoint: paywall?.sessionTokenEndpoint,\n          });\n        res.status(402).send(html);\n        return;\n      }\n      res.status(402).json({\n        x402Version,\n        error: \"X-PAYMENT header is required\",\n        accepts: toJsonSafe(paymentRequirements),\n      });\n      return;\n    }\n\n    let decodedPayment: PaymentPayload;\n    try {\n      decodedPayment = exact.evm.decodePayment(payment);\n      decodedPayment.x402Version = x402Version;\n    } catch (error) {\n      console.error(error);\n      res.status(402).json({\n        x402Version,\n        error: error instanceof Error ? error.message : \"Invalid or malformed payment header\",\n        accepts: toJsonSafe(paymentRequirements),\n      });\n      return;\n    }\n\n    const selectedPaymentRequirements = findMatchingPaymentRequirements(\n      paymentRequirements,\n      decodedPayment,\n    );\n    if (!selectedPaymentRequirements) {\n      res.status(402).json({\n        x402Version,\n        error: \"Unable to find matching payment requirements\",\n        accepts: toJsonSafe(paymentRequirements),\n      });\n      return;\n    }\n\n    try {\n      const response = await verify(decodedPayment, selectedPaymentRequirements);\n      if (!response.isValid) {\n        res.status(402).json({\n          x402Version,\n          error: response.invalidReason,\n          accepts: toJsonSafe(paymentRequirements),\n          payer: response.payer,\n        });\n        return;\n      }\n    } catch (error) {\n      console.error(error);\n      res.status(402).json({\n        x402Version,\n        error: error instanceof Error ? error.message : \"Payment verification failed\",\n        accepts: toJsonSafe(paymentRequirements),\n      });\n      return;\n    }\n\n    // Intercept and buffer all core methods that can commit response to client\n    const originalWriteHead = res.writeHead.bind(res);\n    const originalWrite = res.write.bind(res);\n    const originalEnd = res.end.bind(res);\n    const originalFlushHeaders = res.flushHeaders.bind(res);\n\n    type BufferedCall =\n      | [\"writeHead\", Parameters<typeof originalWriteHead>]\n      | [\"write\", Parameters<typeof originalWrite>]\n      | [\"end\", Parameters<typeof originalEnd>]\n      | [\"flushHeaders\", []];\n    let bufferedCalls: BufferedCall[] = [];\n    let settled = false;\n\n    // Create a promise that resolves when the handler finishes and calls res.end()\n    let endCalled: () => void;\n    const endPromise = new Promise<void>(resolve => {\n      endCalled = resolve;\n    });\n\n    res.writeHead = function (...args: Parameters<typeof originalWriteHead>) {\n      if (!settled) {\n        bufferedCalls.push([\"writeHead\", args]);\n        return res;\n      }\n      return originalWriteHead(...args);\n    } as typeof originalWriteHead;\n\n    res.write = function (...args: Parameters<typeof originalWrite>) {\n      if (!settled) {\n        bufferedCalls.push([\"write\", args]);\n        return true;\n      }\n      return originalWrite(...args);\n    } as typeof originalWrite;\n\n    res.end = function (...args: Parameters<typeof originalEnd>) {\n      if (!settled) {\n        bufferedCalls.push([\"end\", args]);\n        // Signal that the handler has finished\n        endCalled();\n        return res;\n      }\n      return originalEnd(...args);\n    } as typeof originalEnd;\n\n    res.flushHeaders = function () {\n      if (!settled) {\n        bufferedCalls.push([\"flushHeaders\", []]);\n        return;\n      }\n      return originalFlushHeaders();\n    };\n\n    // Proceed to the next middleware or route handler\n    next();\n\n    // Wait for the handler to actually call res.end() before checking status\n    await endPromise;\n\n    // If the response from the protected route is >= 400, do not settle payment\n    if (res.statusCode >= 400) {\n      settled = true; // stop intercepting calls\n      res.writeHead = originalWriteHead;\n      res.write = originalWrite;\n      res.end = originalEnd;\n      res.flushHeaders = originalFlushHeaders;\n      // Replay all buffered calls in order\n      for (const [method, args] of bufferedCalls) {\n        if (method === \"writeHead\")\n          originalWriteHead(...(args as Parameters<typeof originalWriteHead>));\n        else if (method === \"write\") originalWrite(...(args as Parameters<typeof originalWrite>));\n        else if (method === \"end\") originalEnd(...(args as Parameters<typeof originalEnd>));\n        else if (method === \"flushHeaders\") originalFlushHeaders();\n      }\n      bufferedCalls = [];\n      return;\n    }\n\n    try {\n      const settleResponse = await settle(decodedPayment, selectedPaymentRequirements);\n      const responseHeader = settleResponseHeader(settleResponse);\n\n      // if the settle fails, return an error\n      if (!settleResponse.success) {\n        bufferedCalls = [];\n        res.status(402).json({\n          x402Version,\n          error: settleResponse.errorReason,\n          accepts: toJsonSafe(paymentRequirements),\n        });\n        return;\n      }\n\n      res.setHeader(\"X-PAYMENT-RESPONSE\", responseHeader);\n    } catch (error) {\n      console.error(error);\n      // If settlement fails, don't send the buffered response\n      bufferedCalls = [];\n      res.status(402).json({\n        x402Version,\n        error: error instanceof Error ? error.message : \"Payment settlement failed\",\n        accepts: toJsonSafe(paymentRequirements),\n      });\n      return;\n    } finally {\n      settled = true;\n      res.writeHead = originalWriteHead;\n      res.write = originalWrite;\n      res.end = originalEnd;\n      res.flushHeaders = originalFlushHeaders;\n\n      // Replay all buffered calls in order\n      for (const [method, args] of bufferedCalls) {\n        if (method === \"writeHead\")\n          originalWriteHead(...(args as Parameters<typeof originalWriteHead>));\n        else if (method === \"write\") originalWrite(...(args as Parameters<typeof originalWrite>));\n        else if (method === \"end\") originalEnd(...(args as Parameters<typeof originalEnd>));\n        else if (method === \"flushHeaders\") originalFlushHeaders();\n      }\n      bufferedCalls = [];\n    }\n  };\n}\n\nexport type {\n  Money,\n  Network,\n  PaymentMiddlewareConfig,\n  Resource,\n  RouteConfig,\n  RoutesConfig,\n} from \"x402/types\";\nexport type { Address as SolanaAddress } from \"@solana/kit\";\n"],"mappings":"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","names":["paymentMiddleware"]}